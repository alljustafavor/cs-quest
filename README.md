# My Computer Science Learning Journey

**Welcome!** This repository is where I'll document my explorations in computer science, tracking progress, and sharing resources. I aim to grow from a beginner to a well-rounded programmer. I will also be using Python, Javascript, and C.

## Core Areas

* **Programming Fundamentals**
    * [Variables and data types](Programming_Fundamentals/variables_data_types.md) 
    * Operators
    * Control flow (conditionals, loops)
    * Functions
      
    * **Object-Oriented Mastery**
      * Classes, inheritance, polymorphism in depth
      * Abstract classes and interfaces (using Python's `abc` module)
      * Design patterns

   * **Functional Python**
      * Higher-order functions, `map`, `filter`, `reduce`
      * Lambda expressions
      * Closures 

   * **Pythonic Power**
      * Iterators, generators, and yield
      * Decorators for powerful code modification
      * Metaclasses (for the truly ambitious!)

   **Essential Libraries**
      * **NumPy:** High-performance arrays and numerical computing
      * **Pandas:** Data analysis and manipulation
      * **Scikit-learn:** Machine Learning 
      * **Requests:** HTTP interactions 

   **Additional Advanced Topics**
      * **Concurrency and Parallelism:** Threads, processes, asyncio
      * **Testing:** Unit testing, integration testing, mocking
      * **Regular Expressions**
      * **Deployment and Packaging** 

* **Data Structures and Algorithms**
    * Arrays
    * Linked Lists
    * Stacks
    * Queues
    * Hash Table
    * Trees
      * Binary Tree
      * Binary Search Tree
      * Full Biary Tree
      * Complete Binary Tree
      * Balanced Tree
      * Unbalanced Tree
      * **Back Tracking**
        * Finding Hamlitonian Paths
        * Solving N Queen Problem
        * Maze Solving Problem
        * The Knight's Tour Problem
        * Rabin-Karp Algorithm
    * Graphs
      * Directed Graph
      * Undirected Graph
      * Spanning Tree
      * Adjacency Matrix
      * Adjacency List
        * **Greedy Algorithms**
        * Huffman Coding
        * Kruskal's Algorithm
        * Ford-Fulkerson Algoritm
        * Prim's Algorithm
    * Heap
* **Asymptotic Notation**
  * Big-O Notation
  * Big-Θ Notation
  * Big-Ω Notation
  * **Basic Math Skills**
    * Probabilliy
    * Combinatorics
    * **Complexity Classes**
      * P
      * NP
      * Co-NP
      * NP Hard
      * P = NP
      * *NP Complete*
         * Travelling Salesman Problem
         * Knapsac Problem
         * Longest Path Problem

* **Algorithms**
  * **Sorting**
    * Bubble Sort
    * Selection Sort
    * Insertion Sort
    * Heap Sort
    * Quick Sort
    * Merge Sort
  * **Tree**
    * Pre-Order Traversal
    * In-Order Traversal
    * Post Order Traversal
    * Breadth First Search
    * Depth First Search
  * **Graph**
    * Breadth First Search
    * Depth First Search
    * Bellman Ford's Algorithm
    * Dihkstra's Algorithm
    * A* Algorithm
  * **Recursion**
    * Tail Recursion
    * Non-Tail Recursion
  * **Searching**
    * Binary Search
    * Linear Search
  * **Caches**
    * LRU Cache
    * LFU Cache
    * MFU Cache
  * **String Search & Manipulations**
    * Search Pattern in Text
    * Suffix Arrays
    * **Substring Search**
      * Brute Force Search
      * Knuth-Morris Pratt
      * Boyer-Moore
      * Rabin-Karp

* **Design Patterns**
  * GOF Design Patterns
  * Archiectural Patterns
  * Dependency Injection
  * Null Object Pattern
  * Type Object Pattern

* **Computer Architecture and Organization**
    *  CPU, memory, and I/O devices
    * Assembly language basics
    * Number representation  
    * Logic gates and Boolean algebra

* **Operating Systems**
    * Processes and threads
    * Process Forking
    * CPU Interrupts
    * Lock / Mutex / Semaphore
    * Memory management 
    * File systems
    * Scheduling
    * Concurrency and synchronization

* **System Design**
  * Horuzontal vs. Vertical Scaling
  * Load Balancing
  * Clustering
  * Caching
  * CDN
  * Proxy
  * CAP Theorem
  * Queues
  * Architectural Styles
  * **API Design**
    * REST
    * GraphQL
    * gRPC
  * Cloud Design Patterns
  * Long Polling
  * Short Polling
  * Web Sockets
  * SEE

* **Databases**
  * SQL vs NoSQL Database
  * Normalization / Denormalization
  * Entity-Relationship Model
  * DDL
  * DML
  * DQL
  * DCL
  * Locking
  * ACID Model
  * CAP Themorem
  * BASE Model
  * PACELC
  * Indexes
  * Views
  * Transactions
  * Stored Procedures
  * Database Federation
  * Replication
  * Sharding

* **Networking**
    * OSI Model
    * TCP / IP Model
    * DNS
    * HTTP
    * TLS & HTTPS
    * Sockets

* **Security**
  * Public Key Cryptography
  * Hashing
  * Encryption
  * Encoding
  * Hashing Algorithm
  * OWASP
## **New Topic or Update**
* **Example Workflow**
* New Concept: Start studying a topic: "Binary Search Trees."
* New Branch (Optional): If the concept is large or you want to experiment freely, create a branch from your main branch (e.g., "binary-search-tree").
* Notes and Code: Create a new markdown file (e.g., "binary_search_tree.md"). Take notes, write down explanations in your own words, and add code examples as you learn.
* Commit Often: Commit changes as you solidify your understanding or complete sections of your notes.
* Reflection (Periodically): Write a reflective summary in your README, outlining key takeaways and how this concept fits into your understanding of broader computer science.
* Merge or Close Branch: If you used a branch, decide whether to merge your work into the main branch or close it if it was just for experimentation.


